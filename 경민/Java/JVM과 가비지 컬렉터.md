## **📌 알림**
> 해당 글은 공부 목적으로 작성한 글입니다.

<br>

## **📌 JVM(Java Virtual Machine)**

![img](https://user-images.githubusercontent.com/80810465/212921948-754c1ea5-9e53-48c5-9653-6fcae05b1124.png)
   
> **JVM(Java Virtual Machine)**  
> 자바로 작성한 소스 코드를 해석해 실행하기 위한 컴파일러 프로그램이다.  
> JVM은 OS로부터 메모리를 할당 받은 후 메모리를 용도에 따라 여러 영역으로 나누어서 관리한다.    
> <br>  
> **스택 기반의 가상 머신**  
> 인텔x86 아키택처와 같은 하드웨어가 레지스터 기반으로 동작하는데 비해 JVM은 스택 기반으로 동작한다.  
> <br>  
> **심볼릭 레퍼런스**  
> 기본 자료형(primitive data type)을 제외한 모든 타입(클래스와 인터페이스)을 명시적인 메모리 주소 기반의 레퍼런스가 아닌 이름만 가지고 있는 심볼릭 레퍼런스를 통해 참조한다.  
> <br>  
> **가비지 컬렉션(Garbage Collection)**  
> 클래스 인스턴스는 사용자 코드에 의해 명시적으로 생성되고 가비지 컬렉션에 의해 자동으로 제거된다.  
> <br>  
> **기본 자료형을 명확하게 정의하여 플랫폼 독립성 보장**  
> C/C++ 등의 전통적인 언어는 플랫폼에 따라 Int형의 크기가 변하지만 JVM은 기본 자료형을 명확하게 정의하여 호완성을 유지하고 플랫폼 독립성을 보장한다.  
> <br>  
> **네트워크 바이트 오더(Network Byte Order)**  
> 자바 클래스 파일은 네트워크 바이트 오더를 사용한다. 인텔 x86 아키텍처가 사용하는 리틀엔디안이나, RiSC 계열 아키텍처가 주로 사용하는 빅 엔디안 사이에서 플랫폼 독립성을 유지하려면 고정된 바이트 오더를 유지해야 하기에 네트워크 전송 시에 사용하는 바이트 오더인 네트워크 바이트 오더를 사용한다. 네트워크 바이트 오더는 빅 엔디안이다.  
> <br>  
> ※ 바이트 오더(Byte Order) : 시스템의 데이터 표현 방법  
> ※ 빅 엔디안(Big-Endian) : 상위 바이트의 값이 메모리 상에 먼저 표시되는 방법  
> ※ 리틀 엔디안(Little-Endian) : 하위 바이트의 값이 메모리 상에 먼저 표시되는 방법  

<br>

## **📌 JVM 구성 영역**
> JVM은 모든 쓰레드가 공유하는 Method, Heap 영역과 각 쓰레드마다 고유하게 생성하며 쓰레드 종료 시 소멸되는 Stack, Pc Register, Native Method Stack 영역이 있다.  
> <br>  
> **Method Area(Class, Static)**  
> 클래스 파일의 바이트 코드가 로드되는 영역  
> \- 메인 메서드에서 사용하는 클래스와 static 변수가 해당 영역에 저장됨  
> \- 프로그램 클래스 구조를 메타 데이터처럼 가지고 있고 메서드의 코드를 저장해둠  
> \- 메서드 영역의 코드가 올라가는 것을 클래스 로딩이라고 하는데, 메서드가 호출되려면 해당 메서드를 갖고 있는 클래스 파일이 메모리에 로딩되어 있어야 함.  
> <br>  
> **Heap Area**  
> 애플리케이션 실행 중에 생성되는 객체 인스턴스를 저장하는 영역으로, JVM GC(Garbage Collector)에 의해 관리되는 영역  
> <br>  
> **Stack Area**  
> 메서드 호출을 스택 프레임이라는 블록으로 쌓으며, 로컬 변수와 중간 연산 결과들이 저장되는 영역  
> <br>  
> **PC Register**  
> 쓰레드가 현재 실행할 스택 프레임의 주소를 저장하는 영역  
> <br>  
> **Native Method Stack**  
> C/C++ 등의 Low level 코드를 실행하는 스택 영역

<br>

## **📌 JVM 실행 과정**
> **JVM 실행 과정**  
> 1\. OS로부터 메모리Runtime Data Area)를 할당 받음  
> 2\. 컴파일러(javac)가 소스코드(.java)를 읽어 바이트 코드(.class)로 변환  
> 3\. Class Loader를 통해 Class 파일을 JVM 내 Runtime Data Area로 로딩  
> 4\. 로딩된 Class 파일을 Execution Engine을 통해 해석 및 실행

<br>  

## **📌 가비지 컬렉터**

![img (1)](https://user-images.githubusercontent.com/80810465/212922376-be984476-dbf7-489d-a363-83dadcb04888.png)

> **가비지 컬렉터(Garbage Collector)**  
> 메모리 관리 기법 중의 하나로 프로그램이 동적으로 할당했던 메모리 영역 중 필요없게 된 영역을 해제하는 기술이다.  
> <br>  
> **Young Area**  
> 새롭게 생성한 객체의 대부분이 위치하는 영역  
> 대부분의 객체는 생성 후 금새 접근 불가 상태가 되기에 많은 객체가 해당 영역에 생성되었다 사라지는데, 이 때 Minor GC가 발생했다고 한다. Servival 0, 1 영역은 Minor GC로부터 살아남은 객체들이 존재하는 영역으로 0 또는 1 둘 중 하나는 반드시 비어있어야 하며, 메모리 단편화를 막기 위해 둘로 나뉘어져 있다.  
> <br>
> **Old Area**
> 접근 불가 상태가 되지 않고 Young 영역에서 살아남은 객체를 복사해둔 영역  
> 대부분 Young 영역보다 크게 할당하며 크기가 큰 만큼 GC는 적게 발생하며, 이 영역에서 객체가 사라지는 것을 Major GC가 발생했다고 말한다. Old 영역은 기본적으로 데이터가 가득 차면 GC를 실행하는데, GC 방식에 따라 처리하는 절차가 조금씩 달라진다. JDK 7 기준으로 5가지의 GC 방식이 존재한다.  
> \- Serial GC(-XX:+UseSerialGC)  
> \- Parallel GC(-XX:+UseParallelGC)  
> \- Parallel Old GC(-XX:+UseParallelOldGC)  
> \- CMS GC(-XX:+UseConcMarkSeppGC)  
> \- G1 GC(Garbage First)  
> <br>  
> **장점**  
> \- 메모리 누수 방지  
> \- 해제된 메모리 접근 방지  
> \- 해제한 메모리를 다시 이중 해제하는 것 방지  
> <br>
> **단점**  
> \- 개발자가 언제 GC가 메모리를 해제하는지 모름  
> \- 실행중인 애플리케이션이 리소스를 GC 작업에 내줘야 하므로 오버헤드 발생  
>   

<br>

## **📌 모의 면접**   
> **JVM에 대해 설명해주세요.**  
> ---
> 
> 자바로 작성한 소스 코드를 해석해 실행하기 위한 컴파일러 프로그램입니다.  
> JVM은 OS로부터 메모리를 할당 받은 후 메모리를 용도에 따라 여러 영역으로 나누어서 관리합니다. JVM은 크게 Method Area, Heap , Stack, PC Register, Native Method Stack 영역이 존재합니다.  
> <br>  
> Method 영역은 클래스 파일의 바이트 코드가 로드되는 영역으로 메인 메서드에서 사용하는 클래스와 static 변수가 해당 영역에 저장됩니다. 클래스와 인터페이스, 메서드, 필드, static 변수, final 변수 등이 저장되는 영역입니다.  
> Heap 영역은 런타임 시 동적으로 할당하여 사용하는 영역으로, new 연산자로 생성된 객체와 배열 저장하며, JVM 가비지 컬렉터에 의해 관리되는 영역입니다.  
> Stack 영역은 메서드 호출을 스택 프레임이라는 블록으로 쌓으며, 로컬 변수와 중간 연산 결과들이 저장되는 영역입니다.  
> PC Register 영역에서는 쓰레드가 현재 실행할 스택 프레임의 주소를 저장하는 영역입니다.  
> 마지막으로 Native Method Stack 영역은 C/C++ 등의 Low level 코드를 실행하는 스택 영역입니다.  
> <br>
>   
> **JVM 실행 과정에 대해 설명해주세요.**  
> ---
> 
> 먼저 JVM은 OS로부터 Runtime Data 영역의 메모리를 할당받습니다. 그 후 컴파일러가 소스코드를 읽어 바이트 코드로 변환합니다. 컴파일러는 소스 코드를 읽어 클래스 로더를 통해 클래스 파일을 JVM 내 Runtime Data 영역에 클래스를 로딩합니다. 마지막으로 로딩된 클래스 파일을 Execution Engine을 통해 해석 및 실행합니다.  
> <br>
>   
> **가비지 컬렉터에 대해 설명해주세요.**  
> ---
> 
> 가비지 컬렉터는 메모리 관리 기법 중의 하나로 프로그램이 동적으로 할당했던 메모리 영역 중 필요없게 된 영역을 해제하는 기술입니다. 가비지 컬렉터는 크게 새롭게 생성한 객체를 관리하는 Young 영역과 Young 영역에서 살아남은 객체를 관리하는 Old 영역이 존재합니다.  
>   
> 새롭게 생성된 대부분의 객체는 대부분 금새 접근 불가 상태가 되기에 많은 객체가 해당 영역에 생성되었다 사라지는데, 이것을 Minor GC가 발생했다고 말합니다. MinorGC로부터 살아남은 객체들은 Young 영역의 Survival 0, 1 영역에 저장됩니다. Old 영역은 Survival 영역에 저장된 객체들을 복사하여 가져오며, 해당 영역은 보통 Young 영역보다 크게 할당됩니다. 크기가 큰 만큼 GC는 적게 발생하며, 이 영역에서 객체가 사라지는 것을 Major GC가 발생했다고 말합니다. Old 영역은 기본적으로 데이터가 가득 차면 GC를 실행하는데, GC 방식에 따라 처리하는 절차가 조금씩 달라집니다. JDK 7 기준으로 5가지의 GC 방식이 존재합니다.
