## **📌 알림**
> 해당 글은 공부 목적으로 작성한 글입니다.

<br><br>

## **📌 트랜잭션(Transaction)**
> 데이터베이스의 상태를 변화시키는 하나의 논리적인 작업 단위를 말한다.

<br><br>

## **📌 트랜잭션 ACID 원칙**
> 데이터베이스 트랜잭션이 안전하게 수행된다는 것을 보장하기 위한 트랜잭션 시스템의 특성을 정의한 약어이다.  
>   
> **원자성(Atomicity)**  
> 트랜잭션을 구성하는 연산 전체는 모두 정상적으로 실행되거나 모두 취소되어야 한다.  
>   
> **일관성(Consistency)**  
> 트랜잭션 실행을 성공적으로 완료하면 언제나 일관성 있는 데이터베이스 상태로 유지해야 한다.  
>   
> **독립성(Isolation)**  
> 두 개 이상의 트랜잭션이 동시에 발생할 때는 서로의 연산에 영향을 주어서는 안된다.  
>   
> **지속성(Durability)**  
> 커밋된 트랜잭션의 내용은 데이터베이스에 영구히 반영되어야 한다.

<br><br>

## **📌 트랜잭션 상태**

>   
> 트랜잭션의 상태로 활동, 장애, 철회, 부분 완료, 완료가 존재한다.  
>   
> **활동(Active)**  
> 트랜잭션이 실행 중인 상태  
>   
> **장애(Fail)**  
> 트랜잭션이 실행에 오류가 발생하여 중단한 상태  
>   
> **철회(Aborted)**  
> 트랜잭션이 비정상적으로 종료되어 Rollback을 수행하는 상태  
>   
> **부분 완료(Partially Commit)**  
> 트랜잭션이 마지막 연산까지 실행됐지만 Commit 연산이 실행되기 직정 상태  
>   
> **완료(Committed)**  
> 트랜잭션이 성공적으로 종료되어 Commit 연산을 실행한 후의 상태

<br><br>

## **📌 트랜잭션 격리 수준**
> 트랜잭션 격리가 성공하는 정도의 척도를 말하며, 트랜잭션 격리 수준으로 Read Uncommitted, Read Committed, Repeatable Read, Serializable이 존재한다.  
>   
> **Read Uncommitted**  
> 어떤 트랜잭션의 변경 내용이 Commit이나 Rollback과 상관없이 다른 트랜잭션에서 보여지는 정도의 격리 수준이다.  
> \- 조회 시 커밋하지 않은 내용을 조회하는 DIRTY READ가 발생할 수 있다.  
> \- 데이터 정합성 문제가 발생할 가능성이 많다.  
> \- 트랜잭션 Lock 발생 X  
>   
> **Read Committed**  
> 트랜잭션의 변경 내용이 Commit 되어야만 다른 트랜잭션에서 해당 내용을 조회할 수 있는 격리 수준이다.  
> \- 데이터의 값이 변경됐을 때 하나의 트랜잭션 내에서 똑같은 SELECT을 수행했을 경우 다른 결과를 반환하는 NON\_REPETABLE READ가 발생할 수 있다.   
> \- 트랜잭션 Lock 발생 X  
>   
> **Repeatable Read**  
> Commit이 완료된 데이터만 읽을 수 있으며, 트랜잭션 범위 내에서 조회한 내용이 항상 동일함을 보장하는 격리 수준이다.  
> \- 일정 범위의 레코드를 두 번 이상 읽을 때, 첫 번째 쿼리에서 없던 유령 레코드가 두 번째 쿼리에 나타나는 PHANTOM READ가 발생할 수 있다.  
> \- 트랜잭션 Lock 발생 O  
>   
> **Serializable**  
> 한 트랜잭션에서 사용하는 데이터는 다른 트랜잭션에서 접근이 불가능한 격리 수준이다.  
> \- 가장 단순하고 가장 엄격한 격리수준이다.  
> \- 엄격한 격리 수준 때문에 동시처리 능력이 상대적으로 떨어지고, 성능 저하가 발생한다.  
> \- 트랜잭션 Lock 발생 O

<br><br>

## **📌 모의 면접**  
> **트랜잭션과 ACID 원칙에 대해 설명해주세요.**  
> ---
> 
> 트랜잭션은 데이터베이스의 상태를 변화시키는 하나의 논리적인 작업 단위를 말하며, 
> ACID 원칙은 트랜잭션이 안전하게 수행된다는 것을 보장하기 위한 트랜잭션 시스템의 특성을 정의한 약어입니다.  
>   
> **ACID 원칙으로는**  
> 트랜잭션을 구성하는 연산 전체는 모두 정상적으로 실행되거나 모두 취소되어야 한다는 원자성,  
> 트랜잭션 실행을 성공적으로 완료하면 언제나 일관성 있는 데이터베이스 상태로 유지해야 한다는 일관성,  
> 그리고 두 개 이상의 트랜잭션이 동시에 발생할 때는 서로의 연산에 영향을 주어서는 안된다는 독립성,  
> 커밋된 트랜잭션의 내용은 데이터베이스에 영구히 반영되어야 한다는 내용의 지속성이 있습니다.  
> <br>
>  
> **트랜잭션 상태에 대해서 설명해주세요.** 
> ---
>  
> 트랜잭션 상태의 종류는 다섯가지로,  
> 먼저 트랜잭션이 실행 중인 상태인 Active,  
> 트랜잭션이 실행에 오류가 발생하여 중단한 Fail,   
> 트랜잭션이 비정상적으로 종료되어 Rollback을 수행하는 Aborted,  
> 트랜잭션이 마지막 연산까지 실행됐지만 Commit 연산이 실행되기 직전인 상태를 말하는 Partially Committed,  
> 트랜잭션이 성공적으로 종료되어 Commit 연산을 실행한 후의 상태를 말하는 Committed 상태가 있습니다.  
> <br>
> 
> **트랜잭션 격리 수준에 대해 설명해주세요.**
> ---
> 
> **트랜잭션 격리 수준은 트랜잭션 격리가 성공하는 정도의 척도**를 말하며,
> 트랜잭션 격리 수준으로 Read Uncommitted, Read Committed, Repeatable Read, Serializable이 존재합니다.  
> <br>
> 
> **Read Committed 수준은 어떤 트랜잭션의 변경 내용이 Commit이나 Rollback과 상관없이 다른 트랜잭션에서 보여지는 정도의 격리 수준**입니다.
> 
> 트랜잭션 락은 발생하지 않으며, 조회 시 커밋하지 않은 내용을 조회하는 DIRTY READ가 발생할 수 있어 데이터 정합성이 어긋날 확률이 많아 현재 잘 사용되지 않습니다.  
> <br>
> 
> **Read Committed 수준은 트랜잭션의 변경 내용이 Commit 되어야만 다른 트랜잭션에서 해당 내용을 조회할 수 있는 격리 수준**입니다. 
> 
> 트랜잭션 락은 발생하지 않으며, 데이터의 값이 변경됐을 때 하나의 트랜잭션 내에서 똑같은 SELECT을 수행했을 경우 다른 결과를 반환하는 NON\_REPETABLE READ가 발생할 수 있습니다.   
> <br>   
> 
> **Repeatable Read 수준은 Commit이 완료된 데이터만 읽을 수 있는 격리 수준**입니다. 
> 
> 트랜잭션의 락이 발생하며, 트랜잭션 범위 내에서 조회한 내용이 항상 동일함을 보장합니다. 그러나 일정 범위의 레코드를 두 번 이상 읽을 때, 첫 번째 쿼리에서 없던 유령 레코드가 두 번째 쿼리에 나타나는 PHANTOM READ가 발생할 수 있습니다.  
> <br> 
> 
> **Serializable 수준은 한 트랜잭션에서 사용하는 데이터는 다른 트랜잭션에서 접근이 불가능한 격리 수준**입니다. 
> 
> 트랜잭션의 발생하며, 다른 트랜잭션에서 접근이 불가능하기 때문에 가장 단순하고 가장 엄격한 격리 수준입니다. 그러나 엄격한 격리 수준 때문에 동시처리 능력이 상대적으로 떨어지고, 성능 저하가 발생한다는 문제점이 있습니다.
