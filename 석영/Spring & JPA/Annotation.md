![image](https://user-images.githubusercontent.com/96826217/213880675-5b994a70-0f58-40fd-93e0-adf7c1275122.png)

## **🔎 어노테이션이란❓**

어노테이션(Annotation)은 메타데이터(metadata)라고 볼 수 있다. 메타데이터는 Application이 처리하는 데이터가 아니고, 컴파일 과정과 런타임 과정에서 코드를 어떻게 컴파일하고 처리할 것인지 알려주는 정보이다. 

> ex) @AnnotationName

#### **⚈ 어노테이션의 용도**

-   컴파일러에게 코드 문법 에러를 체크하도록 정보를 제공
-   소프트웨어 개발 툴이 빌드나 배치 시 코드를 자동으로 생성할 수 있도록 정보를 제공
-   실행 시(런타임 시) 특정 기능을 실행하도록 정보를 제공

컴파일러에게 코드 문법 에러를 체크하도록 정보를 제공하는 대표적인 예는 @Override 어노테이션이다. 예를 들어 부모 클래스의 메소드를 재정의하여 사용할 때 컴파일 시 상위타입(부모클래스, 인터페이스)에 해당 메서드가 존재하는지 확인하고 만약 존재하지 않는다면 컴파일 에러를 발생시킨다. 어노테이션은 빌드 시 자동으로 XML 설정 파일을 생성하거나, 배포를 위해 JAR 압축 파일을 생성하는 데에도 사용되고 실행 시 클래스의 역할을 정의하기도 한다.

#### **⚈ 어노테이션의 정의**

어노테이션 타입을 정의하는 방법은 인터페이스를 정의하는 것과 유사하다.

```
public @interface AnnotationName{

}
```

이렇게 정의한 어노테이션은 코드에서 @AnnotaionName과 같이 사용한다.

어노테이션은 클래스의 필드처럼 엘리먼트로 멤버를 가질 수 있다. 각 엘리먼트는 타입과 이름으로 구성되고, 디폴트 값을 가질 수 있다. 

엘리먼트 타입으로는 int나 double과 같은 원시타입이나 String, Class 타입, 그리고 이들의 배열 타입을 사용할 수 있다.

```
public @interface AnnotationName{
    String elementName1();        // 엘리먼트 선언
    int elementName2() default 5;
}
```

이렇게 정의한 어노테이션을 코드에서 적용할 때에는 이렇게 사용한다.

```
@Annotation(elementName1="값", elementName2=3);
또는
@AnnotationName(elementName1 = "값");
```

elementName1은 디폴트 값이 없기 때문에 반드시 값을 기술해야 하고, elementName2는 디폴트 값이 있기 때문에 생략 가능하다. 어노테이션은 기본 엘리먼트인 value를 가질 수 있고 value 엘리먼트를 가진 어노테이션을 코드에서 적용할 때에는 값만 기술할 수 있다. 이 값은 기본 엘리먼트인 value 값으로 자동 설정된다.

