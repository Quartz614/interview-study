![image](https://user-images.githubusercontent.com/96826217/212541778-0bf06026-77d2-49c5-b6a0-1b58278cf416.png)

## **🔎 트랜잭션 이란❓**

트랜잭션은 데이터베이스의 상태를 변환시키기 위한 작업 수행의 논리적 단위를 의미한다. 우리는 데이터베이스로 SQL 쿼리를 보냄으로써 데이터베이스의 상태를 변화시킨다. 여기서 작업 단위는 사용자가 특정 기능의 수행을 위해 SQL 작업을 묶은 단위를 의미한다.

송금 서비스를 예로 들면, 송금 서비스는 **1\. A가 돈을 보내고, 2. B가 그 돈을 안전하게 받았을 때** 완전히 실행이 됐다고 할 수 있다. 두 과정이 다른 트랜젝션, 즉 다른 작업으로 분리되었다고 생각해 보면,

A가 돈을 10000원 송금하면 A의 돈 데이터에서 10000원이 차감될 것이다. 그에 맞춰서 B의 잔고는 10000원이 추가될 것이다. 만약 A의 로직에서 오류가 발생해 트랜젝션 rollback이 일어난다면 A의 돈 데이터는 다시 10000원이 추가됨으로써 원상복구가 될 것이다. 하지만 B의 돈은 어떠한가? 다른 트랜젝션으로 분류되었기에 아무런 rollback도 일어나지 않기 때문에 **돈이 추가된 상태로 남게 된다.**

송금 과정을 하나의 작업 단위로 묶지 않으면 당사자들 간의 데이터 불일치가 나타날 수 있다. 우리는 두 과정을 **하나의 트랜젝션**으로 묶어야 한다. 그래야 중간에 문제가 발생해도 두 과정 모두 rollback이 일어날 수 있다.

이처럼 작업 단위를 잘 설정하는 것은 서비스를 구성함에 있어서 매우 중요한 부분이다. 트랜젝션이 성공적으로 마무리되었다면 commit을 호출해서 수정 사항을 DB에 영구적으로 반영하고, 중간에 오류가 발생했다면 **rollback**을 호출해서 트랜젝션 내부의 모든 작업을 원상복구 시킨다.

**DBMS의 성능은 초당 트랜잭션의 실행 수**( **TPS** : Transaction per second )로 측정한다.

---

### ⚈ 트랜잭션의 특성(ACID)

#### Atomicity(원자성)

1.  트랜잭션의 연산은 데이터베이스에 모두 반영되든지 전혀 반영되지 않아야 한다.
2.  트랜잭션 내의 모든 명령은 반드시 완벽히 수행되어야 하며, 모두가 완벽히 수행되지 않고 어느 하나라도 오류가 발생하면 트랜잭션 전부가 취소되어야 한다.

#### Consistency(일관성)

1.  트랜잭션이 그 실행을 성공적으로 완료하면 언제나 일관성 있는 데이터 베이스 상태로 변환한다.
2.  시스템이 가지고 있는 고정요소는 트랜잭션 수행 전과 트랜잭션 수행 완료 후의 상태가 같아야 한다.

#### Isolation(독립성, 격리성)

1.  둘 이상의 트랜잭션이 동시에 병행 실행되는 경우 어느 하나의 트랜잭션 실행 중에 다른 트랜잭션의 연산이 끼어들 수 없다.
2.  수행 중인 트랜잭션은 완전히 완료될 때까지 다른 트랜잭션에서 수행 결과를 참조할 수 없다.

#### Durablility(용속성, 지속성)

1.  성공적으로 완료된 트랜잭션의 결과는 시스템이 고장 나더라도 영구적으로 반영되어야 한다.

---

### ⚈ 트랜잭션 격리 수준(Transaction Isolation Level)

트랜잭션 격리 수준은 트랜잭션에서 일관성 없는 데이터를 허용하도록 하는 수준을 말한다.

데이터베이스는 ACID 특징과 같이 트랜잭션이 독립적인 수행을 하도록 하는데, Locking을 통해, 트랜잭션이 DB를 다루는 동안 다른 트랜잭션이 관여하지 못하도록 막는 것이 필요하다.

하지만 무조건 Locking으로 동시에 수행되는 수많은 트랜잭션들을 순서대로 처리하는 방식으로 구현하게 되면 데이터 베이스의 성능은 떨어지게 된다.

하지만 성능을 높이기 위해 Locking 범위를 줄이면 잘못된 값이 처리될 문제가 발생하기 때문에 최대한 효율적인 Locking 방법이 필요하다.

#### Isolation level 종류

1\. Read Uncommitted (레벨 0)

> SELECT 문장이 수행되는 동안 해당 데이터에 Shared Lock이 걸리지 않는 계층  
> 트랜잭션에 처리 중이거나, 아직 Commit 되지 않은 데이터를 다른 트랜잭션이 읽는 것을 허용한다.  
> 데이터베이스의 일관성을 유지하는 것이 불가능하다.

2\. Read Committed (레벨 1)

> SELECT 문장이 수행되는 동안 해당 데이터에 Shared Lock이 걸리는 계층  
> 트랜잭션이 수행되는 동안 다른 트랜잭션이 접근할 수 없어 대기하게 된다.  
> Commit이 이루어진 트랜잭션만 조회 가능  
> 대부분의 SQL 서버가 Default로 사용하는 Isolation Level이다.

3\. Repeatable Read (레벨 2)

> 트랜잭션이 완료될 때까지 SELECT 문장이 사용하는 모든 데이터에 Shared Lock이 걸리는 계층  
> 트랜잭션이 범위 내에서 조회한 데이터 내용이 항상 동일함을 보장한다.  
> 다른 사용자는 트랜잭션 영역에 해당되는 데이터에 대한 수정이 불가능하다.  
> MySQL에서 Default로 사용하는 Isolation Level이다.

4\. Serializable (레벨 3)

> 트랜잭션이 완료될 때까지 SELECT 문장이 사용하는 모든 데이터에 Shared Lock이 걸리는 계층  
> 완벽한 읽기 일관성 모드를 제공한다.  
> 다른 사용자는 트랜잭션 영역에 해당되는 데이터에 대한 수정 및 입력이 불가능하다.

#### **⚈ Isolation Level 선택 시 고려사항**

Isolation Level에 대한 조정은, 동시성과 데이터 무결성에 연관되어 있다. 동시성을 증가시키면 데이터 무결성에 문제가 발생하고, 데이터 무결성을 유지하면 동시성이 떨어지게 된다.

레벨을 늪에 조정할수록 발생하는 비용이 증가한다.

#### **⚈ 낮은 단계 Isolation Level을 활용할 때 발생하는 현상들**

**✔️** Dirty Read

커밋되지 않은 수정 중인 데이터를 다른 트랜잭션에서 읽을 수 있도록 허용할 때 발생하는 현상이다. 어떤 트랜잭션에서 아직 실행이 끝나지 않은 다른 트랜잭션에 의한 변경사항을 보게 되는 경우이다. 

발생 Level : Read Uncommitted

✔️ Non-Repeatable Read

한 트랜잭션에서 같은 쿼리룰 두 번 수행할 때 그 사이에 다른 트랜잭션 값을 수정 또는 삭제하면서 두 쿼리의 결과가 상이하게 나타나는 일관성이 깨진 현상이다.

발생 Level : Read Committed, Read Uncommitted

✔️ Phantom Read

한 트랜잭션 안에서 일정 범위의 레코드를 두 번 이상 읽었을 때, 첫 번째 쿼리에서 없던 레코드가 두 번째 쿼리에서 나타나는 현상이다.

트랜잭션 도중 새로운 레코드 삽입을 하용하기 때문에 나타나는 현상이다.

발생 Level : Repeatable Read, Read Committed, Read Uncommitted
